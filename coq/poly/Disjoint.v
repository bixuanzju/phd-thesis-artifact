
Require Import Infrastructure.


(* ********************************************************************** *)
(** * Properties of disjointness *)

Lemma disjoint_swft : forall Δ A B,
    disjoint Δ A B ->
    swft Δ A /\ swft Δ B.
Proof with eauto using same_eq.
  introv Dis.
  induction* Dis.

  splits...
  eapply sub_swft...

  splits...
  eapply sub_swft...

  splits...

  pick fresh X and apply swft_all...
  apply swft_change with (Δ := ([(X , sty_and A1 A2)] ++ DD))...
  eapply H0...

  pick fresh X and apply swft_all...
  apply swft_change with (Δ := ([(X , sty_and A1 A2)] ++ DD))...
  eapply H0...
Qed.


Lemma disjoint_and : forall Δ A B C,
    lc_sty A ->
    disjoint Δ A (sty_and B C) <->
    disjoint Δ A B /\ disjoint Δ A C.
Proof with eauto.
  introv LCA.
  induction LCA.

  - splits...
    introv Dis.
    inverts Dis...

    introv Dis.
    destruct Dis...

  - splits...
    introv Dis.
    lets (? & Wft): disjoint_swft Dis.
    inverts Wft...


    introv Dis.
    destruct Dis...


  - splits...
    introv Dis.
    inverts Dis...
    splits...
    forwards (c1 & c2 & Sub1 & Sub2) : sub_andr H2...
    forwards (c1 & c2 & Sub1 & Sub2) : sub_andr H2...

    introv Dis.
    destruct Dis...


  - splits...
    introv Dis.
    inverts Dis...

    introv Dis.
    inverts Dis...

  - splits...
    introv Dis.
    inverts Dis as Dis1 Dis2.
    apply IHLCA1 in Dis1...
    apply IHLCA2 in Dis2...
    destructs Dis1...
    destructs Dis2...
    splits...

    introv Dis.
    inverts Dis...

  - splits...
    introv Dis.
    inverts Dis...

    introv Dis.
    inverts Dis...

  - splits...
    introv Dis.
    inverts Dis...

    introv Dis.
    inverts Dis...

Qed.


(* BEGIN_DISJOINT_NARROW *)
Lemma disjoint_narrow : forall F X U T E A B c,
    disjoint (F ++ X ~ U ++ E) A B ->
    sub E T U c ->
    uniq (F ++ X ~ U ++ E) ->
    disjoint (F ++ X ~ T ++ E) A B.
Proof with eauto using swft_narrow, sub_narrow.
  introv Dis.
  remember (F ++ X ~ U ++ E) as G.
  generalize dependent F.
  induction Dis; introv EQ Uniq Sub; subst...

  - Case "Var1".
    analyze_binds_uniq H...
    assert (sub (F ++ X ~ T ++ E) T B (co_trans c0 c)).
      eapply S_trans...
      rewrite_env (nil ++ (F ++ [(X, T)]) ++ E).
      apply sub_weakening...
      solve_uniq.
    eapply D_tvarL...

  - Case "Var2".
    analyze_binds_uniq H...
    assert (sub (F ++ X ~ T ++ E) T B (co_trans c0 c)).
      eapply S_trans...
      rewrite_env (nil ++ (F ++ [(X, T)]) ++ E).
      apply sub_weakening...
      solve_uniq.
    eapply D_tvarR...

  - Case "forall".
    pick fresh Y and apply D_forall...
    rewrite_env (([(Y, sty_and A1 A2)] ++ F) ++ [(X, T)] ++ E)...
Qed.



(* BEGIN_DISJOINT_SYMM *)
Lemma disjoint_symmetric: forall Δ A B,
    disjoint Δ A B ->
    uniq Δ ->
    disjoint Δ B A.
Proof with eauto.
  introv Dis.
  induction Dis; introv Uniq...
  pick fresh X and apply D_forall...

  rewrite_env (nil ++ [(X, sty_and A2 A1)] ++ DD).
  eapply disjoint_narrow...


Qed.


(* BEGIN_DISJOINT_CO *)
Lemma disjoint_sub : forall Δ Δ' A B C c,
    sub Δ' B C c ->
    same_stctx Δ' Δ ->
    swfte Δ ->
    disjoint Δ A B ->
    disjoint Δ A C.
Proof with eauto using swft_type.
  introv Sub.
  gen A Δ.

  induction Sub; introv Same Wfte Dis...

  - Case "top".
    lets (? & ?) : disjoint_swft Dis...

  - Case "topArr".
    forwards (WFA & ?) : disjoint_swft Dis...
    induction WFA...
    + SCase "A is and".
      constructor...

  - Case "topRcd".
    forwards (WFA & ?) : disjoint_swft Dis...
    induction WFA...
    + SCase "A is and".
      constructor...

    + SCase "A is record".
      destruct (l == l0); substs...

  - Case "topAll".
    forwards (WFA & ?) : disjoint_swft Dis...
    induction WFA...

    + SCase "A is forall".
      pick fresh X and apply D_forall...

    + SCase "A is and".
      constructor...

  - Case "arr".
    forwards (WFA & WFB) : disjoint_swft Dis...
    apply sub_change with (Δ' := Δ) in Sub1...
    apply sub_change with (Δ' := Δ) in Sub2...
    inverts WFB.
    forwards (? & ?) : sub_swft Sub1...
    forwards (? & ?) : sub_swft Sub2...
    induction WFA...

    + SCase "A is var".
      inverts Dis...
    + SCase "A is arrow".
      inverts Dis...

    + SCase "A is and".
      inverts Dis...

  - Case "andl".
    forwards (? & ?) : disjoint_swft Dis...
    apply disjoint_and in Dis...
    destruct Dis...

  - Case "andr".
    forwards (? & ?) : disjoint_swft Dis...
    apply disjoint_and in Dis...
    destruct Dis...

  - Case "forall".
    forwards (WFA & ?) : disjoint_swft Dis...
    assert (Sub2 : sub DD (sty_all A1 B1) (sty_all A2 B2) (co_forall c))...
    apply sub_change with (Δ' := Δ) in Sub...
    apply sub_change with (Δ' := Δ) in Sub2...
    forwards (? & ?) : sub_swft Sub...
    lets (? & ?) : sub_swft Sub2.
    induction WFA...

    + SCase "A is var".
      inverts Dis...

    + SCase "A is all".
      inverts Dis...
      pick fresh X and apply D_forall...
      eapply H0...
      rewrite_env (nil ++ [(X, sty_and A A2)] ++ DD0).
      eapply disjoint_narrow...

    + SCase "A is and".
      inverts Dis...

  - Case "rcd".
    forwards (WFA & ?) : disjoint_swft Dis...
    apply sub_change with (Δ' := Δ) in Sub...
    forwards (? & ?) : sub_swft Sub...
    induction WFA...

    + SCase "A is var".
      inverts Dis...

    + SCase "A is and".
      inverts Dis...

    + SCase "A is record".
      inverts Dis...


  - Case "distArr".
    forwards (WFA & ?) : disjoint_swft Dis...
    apply swft_change with (Δ' := Δ) in H...
    apply swft_change with (Δ' := Δ) in H0...
    apply swft_change with (Δ' := Δ) in H1...
    induction WFA...

    + SCase "A is var".
      inverts Dis as Dis1 Dis2...
      inverts Dis1 as Bind1 ?...
      inverts Dis2 as Bind2 ?...
      lets Uniq : uniq_from_swfte Wfte...
      forwards : binds_unique Bind1 H3 Uniq...
      substs...
      forwards : binds_unique Bind2 H3 Uniq...
      substs...


    + SCase "A is arrow".
      inverts Dis as Dis1  Dis2.
      inverts Dis1...
      inverts Dis2...

    + SCase "A is and".
      apply disjoint_and in Dis...
      inverts Dis as Dis1 Dis2...
      inverts Dis1...
      inverts Dis2...
      constructor...

  - Case "distRcd".
    forwards (WFA & ?) : disjoint_swft Dis...
    apply swft_change with (Δ' := Δ) in H...
    apply swft_change with (Δ' := Δ) in H0...
    induction WFA...

    + SCase "A is var".
      inverts Dis as Dis1 Dis2...
      inverts Dis1 as Bind1 ?.
      inverts Dis2 as Bind2 ?.
      lets Uniq : uniq_from_swfte Wfte.
      forwards : binds_unique Bind1 H2 Uniq.
      substs...
      forwards : binds_unique Bind2 H2 Uniq.
      substs...

    + SCase "A is and".
      apply disjoint_and in Dis...
      inverts Dis as Dis1 Dis2...
      inverts Dis1...
      inverts Dis2...
      constructor...


    + SCase "A is record".
      inverts Dis as Dis1 Dis2.
      inverts Dis1...
      inverts Dis2...

  - Case "distPoly".
    forwards (WFA & WFB) : disjoint_swft Dis...
    inverts WFB as WFB1 WFB2.
    assert (swft Δ (sty_all A (sty_and B1 B2))).
      inverts WFB2.
      inverts WFB1.
      pick fresh X and apply swft_all...
      unfold open_sty_wrt_sty.
      simpl...

    induction WFA...

    + SCase "A is var".
      apply disjoint_and in Dis...
      inverts Dis as Dis1 Dis2.
      inverts Dis1 as Bind1 ?.
      inverts Dis2 as Bind2 ?.
      lets Uniq : uniq_from_swfte Wfte.
      forwards : binds_unique Bind1 H3 Uniq.
      substs.
      forwards : binds_unique Bind2 H3 Uniq.
      substs.

      apply D_tvarL with (A := A0) (c := co_trans co_distPoly (co_pair c c0))...
      eapply S_trans...
      eapply S_distPoly...

    + SCase "A is all".
      inverts Dis as Dis1 Dis2.
      inverts Dis1.
      inverts Dis2.
      pick fresh X and apply D_forall...

      unfold open_sty_wrt_sty.
      simpls...

    + SCase "A is and".
      apply disjoint_and in Dis...
      inverts Dis as Dis1 Dis2.
      apply disjoint_symmetric in Dis1...
      apply disjoint_symmetric in Dis2...
      apply disjoint_and in Dis1...
      apply disjoint_and in Dis2...
      inverts Dis1 as HH1 HH2.
      inverts Dis2 as HH3 HH4.
      apply disjoint_symmetric in HH1...
      apply disjoint_symmetric in HH2...
      apply disjoint_symmetric in HH3...
      apply disjoint_symmetric in HH4...

      constructor...

      (* WTF? *)
      Unshelve.
      exact (dom DD).
      exact (dom DD).
      exact (dom DD).
      exact (dom DD).


Qed.



Lemma disjoint_weakening : forall G F E A B,
  disjoint (G ++ E) A B ->
  uniq (G ++ F ++ E) ->
  disjoint (G ++ F ++ E) A B.
Proof with eauto using sub_weakening, swft_weaken.
  introv Dis.
  remember (G ++ E) as H.
  generalize dependent G.
  induction Dis; introv EQ Ok; subst...

  pick fresh X and apply D_forall...
  rewrite_env (([(X, sty_and A1 A2)] ++ G) ++ F ++ E).
  eapply H0...
  solve_uniq.
Qed.

Lemma disjoint_subst : forall Z E F C A B P,
  disjoint (F ++ Z ~ C ++ E) A B ->
  swfte (F ++ Z ~ C ++ E) ->
  swft E P ->
  disjoint E P C ->
  swfte (map (subst_sty_in_sty P Z) F ++ E) ->
  disjoint (map (subst_sty_in_sty P Z) F ++ E) (subst_sty_in_sty P Z A) (subst_sty_in_sty P Z B).
Proof with eauto using subst_sty_in_sty_lc_sty, swft_subst_tb, swft_type, same_eq.
  introv WT EP.
  remember (F ++ Z ~ C ++ E) as G.
  generalize dependent F.
  induction WT; introv Eq Wft Dis Uniq; substs; simpl...

  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...
  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...
  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...
  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...
  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...
  constructor;
  replace (sty_all (subst_sty_in_sty P Z A1) (subst_sty_in_sty P Z B1)) with (subst_sty_in_sty P Z (sty_all A1 B1))...


  - Case "Var1".
    case_if.
    substs.
    analyze_binds_uniq H...
    substs...
    apply disjoint_sub with (Δ' := (map (subst_sty_in_sty P Z) F ++ E)) (B := (subst_sty_in_sty P Z C)) (c := c)...
    eapply sub_subst...
    replace (subst_sty_in_sty P Z C) with C.
    rewrite_env (nil ++ map (subst_sty_in_sty P Z) F ++ E).
    eapply disjoint_weakening...
    rewrite subst_sty_in_sty_fresh_eq...
    clear Uniq.
    eapply swfte_tvar...

    analyze_binds_uniq H...
    eapply D_tvarL...
    eapply sub_subst...

    eapply D_tvarL...
    replace A with (subst_sty_in_sty P Z A).
    eapply sub_subst...
    rewrite subst_sty_in_sty_fresh_eq...
    apply swft_tvar with (D := E)...
    eapply swft_from_swfte...
    eapply swfte_strength...
    inverts BindsTacSideCond0...


  - Case "Var2".
    eapply disjoint_symmetric...
    case_if.
    substs.
    analyze_binds_uniq H...
    substs...
    apply disjoint_sub with (Δ' := (map (subst_sty_in_sty P Z) F ++ E)) (B := (subst_sty_in_sty P Z C)) (c := c)...
    eapply sub_subst...
    replace (subst_sty_in_sty P Z C) with C.
    rewrite_env (nil ++ map (subst_sty_in_sty P Z) F ++ E).
    eapply disjoint_weakening...
    rewrite subst_sty_in_sty_fresh_eq...
    clear Uniq.
    eapply swfte_tvar...

    analyze_binds_uniq H...
    eapply D_tvarL...
    eapply sub_subst...

    eapply D_tvarL...
    replace A with (subst_sty_in_sty P Z A).
    eapply sub_subst...
    rewrite subst_sty_in_sty_fresh_eq...
    apply swft_tvar with (D := E)...
    eapply swft_from_swfte...
    eapply swfte_strength...
    inverts BindsTacSideCond0...


  - Case "forall".

    pick fresh Y and apply D_forall...
    rewrite subst_sty_in_sty_open_sty_wrt_sty_var...
    rewrite subst_sty_in_sty_open_sty_wrt_sty_var...
    rewrite_env (map (subst_sty_in_sty P Z) ([(Y, sty_and A1 A2)] ++ F) ++ E).
    apply H0...

    simpl; constructor...

Qed.

Lemma rel_d_tvar_disjoint : forall Δ p X A,
    rel_d Δ p ->
    swfte Δ ->
    binds X A Δ ->
    disjoint nil (mtsubst_in_sty p (sty_var_f X) ) (mtsubst_in_sty p A).
Proof with eauto.
  introv RelD.
  gen X A.
  induction RelD; introv Swft Bind; simpls...

  case_if.
  + SCase "X0 = X".
    substs.
    forwards (? & ?): rel_d_uniq RelD.
    analyze_binds_uniq Bind...
    inverts Swft...
    rewrite mtsubst_fresh...
    rewrite subst_sty_in_sty_fresh_eq...
    eapply swft_tvar...
  + SCase "X0 <> X".
    forwards (? & ?): rel_d_uniq RelD.
    analyze_binds_uniq Bind...
    inverts Swft as Swft ?.
    forwards Dis : IHRelD Swft...
    applys_eq Dis 1.
    rewrite subst_sty_in_sty_fresh_eq...
    eapply swft_tvar...
Qed.



Lemma mtsubst_disjoint_helper : forall A B Δ1 Δ2 p,
    rel_d Δ2 p ->
    swfte (Δ1 ++ Δ2) ->
    disjoint (Δ1 ++ Δ2) A B ->
    disjoint (map (mtsubst_in_sty p) Δ1) (mtsubst_in_sty p A) (mtsubst_in_sty p B).
Proof with eauto.
  introv Eq Wfte Dis.
  gen p.
  inductions Dis; introv Eq; simpls;
    autorewrite with lr_rewrite;
    try (constructor; eauto);
    try(solve[rewrite <- mtsubst_forall; eauto]).


  + Case "var1".
    analyze_binds_uniq H...
    rewrite mtsubst_tvar_notin...
    apply D_tvarL with (A := (mtsubst_in_sty p A)) (c := c)...
    eapply sub_subst_ctx...
    eapply rel_d_notin...
    forwards : rel_d_tvar_disjoint Eq BindsTac...
    eapply swfte_strength...
    apply disjoint_sub with (Δ' := (map (mtsubst_in_sty p) Δ1)) (B := (mtsubst_in_sty p A)) (c := c)...
    eapply sub_subst_ctx...
    eapply swfte_subst_ctx...
    rewrite_env (nil ++ map (mtsubst_in_sty p) Δ1 ++ nil).
    eapply disjoint_weakening...
    solve_uniq.

  + Case "var2".
    analyze_binds_uniq H...
    rewrite mtsubst_tvar_notin...
    apply D_tvarR with (A := (mtsubst_in_sty p A)) (c := c)...
    eapply sub_subst_ctx...
    eapply rel_d_notin...
    forwards : rel_d_tvar_disjoint Eq BindsTac...
    eapply swfte_strength...
    eapply disjoint_symmetric...
    apply disjoint_sub with (Δ' := (map (mtsubst_in_sty p) Δ1)) (B := (mtsubst_in_sty p A)) (c := c)...
    eapply sub_subst_ctx...
    eapply swfte_subst_ctx...
    rewrite_env (nil ++ map (mtsubst_in_sty p) Δ1 ++ nil).
    eapply disjoint_weakening...
    solve_uniq.
    solve_uniq.

  + Case "forall".
    pick fresh X and apply D_forall; simpl_env...
    lets (? & ?) : rel_d_uniq Eq.
    forwards Imp : H0 X Δ2 ([(X, sty_and A1 A2)] ++ Δ1) p...
    simpl_env...
    simpls...
    erewrite mtsubst_open in Imp...
    rewrite mtsubst_tvar_notin in Imp...
    erewrite mtsubst_open in Imp...
    rewrite mtsubst_tvar_notin in Imp...
    autorewrite with lr_rewrite in Imp...
Qed.

Lemma mtsubst_disjoint : forall A B Δ p,
    rel_d Δ p ->
    swfte Δ ->
    disjoint Δ A B ->
    disjoint nil (mtsubst_in_sty p A) (mtsubst_in_sty p B).
Proof with eauto.
  intros.
  rewrite_env (map (mtsubst_in_sty p) nil).
  eapply mtsubst_disjoint_helper...
Qed.
